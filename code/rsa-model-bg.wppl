// define card deck
const cards_in_deck = {1: 3, 2: 2, 3: 2, 4: 2, 5: 1};
let entire_context = {
  "red-1": 3, "blue-1": 3, "green-1": 3, "white-1": 3, "yellow-1": 3,
  "red-2": 2, "blue-2": 2, "green-2": 2, "white-2": 2, "yellow-2": 2,
  "red-3": 2, "blue-3": 2, "green-3": 2, "white-3": 2, "yellow-3": 2,
  "red-4": 2, "blue-4": 2, "green-4": 2, "white-4": 2, "yellow-4": 2,
  "red-5": 1, "blue-5": 1, "green-5": 1, "white-5": 1, "yellow-5": 1
}

const intentions = ["play", "discard", "hint"]
const suits = ["red", "blue", "green", "white", "yellow"]
const numbers = ["1", "2", "3", "4", "5"]
const utterances = suits.concat(numbers);
const actions = utterances.concat(["play", "discard"])
const PLAYERS = ['player1', 'player2', 'player3']


// @arg card: color+nb, e.g. red-1, blue-3
let LiteralMeaning = function(card, utt){
  return card.includes(utt)
}

globalStore.context_game = {"discarded": [], "played": ["red-1"],
                            "nb_hints": 8, "lifes": 3};

let cardsGlobal = function(){
  let discarded = globalStore.context_game.discarded
  let played = globalStore.context_game.played
  let cards_seen = discarded.concat(played)
  return cards_seen
}

// context of one or more players, players: ['player1', ...]
let contextPlayers = function(players){
 let joint_observations = reduce(function(player_i, acc){
  let cards = players.includes(player_i) ? [] : deck[player_i]
  acc.concat(cards)
  }, [], PLAYERS);
//  let jointly_visible = _.countBy(joint_observations);
 let global_observations = cardsGlobal();
 let context = joint_observations.concat(global_observations);
 return _.countBy(context);
}

let deck = {"player1": ["red-1", "red-2", "green-5", "yellow-4", "blue-3"],
            "player2": ["green-2", "white-2", "blue-1", "yellow-4", "red-1"],
            "player3": ["white-5", "white-4", "blue-2", "yellow-3", "yellow-1"]}
const POSITIONS = _.range(0, deck.player1.length)


let toBePlayed = function(card_known){
  let color = card_known.color; let nb = card_known.nb;

  let cond1 = globalStore.context_game.played.includes([color,(nb-1)].join('-')) &&
    !globalStore.context_game.played.includes([color, (nb+1)].join('-'))
  let cond2 = globalStore.context_game.played.length == 0 && card_known.nb == 1
  return cond1 || cond2
}

let sampleIntent = function(card_known, nb_card_unseen){
  let playable = toBePlayed(card_known)
  let critical = nb_card_unseen == 1
  let intent = playable ? "playable" : critical ? "keep" :
   (card_known.nb == "unknown" && card_known.color == "unknown") ? "irrelevant" :
   (card_known.nb == "unknown" || card_known.color == "unknown") ? "relevant" :
   "discardable"
  //todo discardable: known that not needed anymore, atm discardable never chosen
  //todo keep: difference between keep because critical or only potentially critical because the player already sees the card in another player's hand
//   print(card_known.color + '-' + card_known.nb + ': ' + intent)
  return intent
}

// what player thinks about observer's cards
// todo: hint must be replaced by what player knows about own cards
var PriorCards =function(player, observer, hint){
  let context = contextPlayers([player, observer]);
  let params = reduce(function(card_nb, acc){
    let nb_total = card_nb[1]
    let all_seen = Object.keys(context).includes(card_nb[0]) ?
        context[card_nb[0]] == nb_total : false
    all_seen ? acc.concat([[card_nb[0], 0]]) : acc.concat([[card_nb[0], 1]]);
  }, [], Object.entries(entire_context))
  let vs_ps = _.unzip(params)

  return Infer({model:function(){
    let card = categorical({vs: vs_ps[0], ps: vs_ps[1]})
    let pos = uniformDraw([0, 1, 2, 3, 4])
    // todo merge with knowedge what player_to knows about her cards indep of hint
    let card_known = (hint.pos.includes(pos) && card.includes(hint.utt)) ? hint :
     {nb: 'unknown', color: 'unknown'}
    let intent = sampleIntent(card_known, context[card])
    return {pos, card, intent}
  }})
}

// hint = {utt: 'unknown', color: 'unknown', nb: 'unknown'} if no hint given
var EgerPriorCards =function(player, observer, hint){
  let context = contextPlayers([player, observer]);
//   print(context)
  let remaining_cards = reduce(function(card_nb, acc){
    let nb_total = card_nb[1]
    let nb_seen = Object.keys(context).includes(card_nb[0]) ? context[card_nb[0]] : 0
    let nb_missing = nb_total - nb_seen
    acc.concat(repeat(nb_missing, function(){return card_nb[0]}))
  }, [], Object.entries(entire_context))

//   print('remaining')
//   print(remaining_cards)
//   print(remaining_cards.length)

  return Infer({model:function(){
    let card = uniformDraw(remaining_cards)
    let pos = uniformDraw([0, 1, 2, 3, 4])
    // todo merge with knowedge what player_to knows about her cards indep of hint
    let card_known = (hint.pos.includes(pos) && card.includes(hint.utt)) ? hint :
     {nb: 'unknown', color: 'unknown'}
    let intent = sampleIntent(card_known, context[card])
    return {pos, card, intent}
  }})
}

let LiteralListener = function(player_to, player_from, hint, prior_type){
  player_to === player_from ? error(player_to+' cant hint at '+player_from) : null;
  return Infer({model: function(){
    let prior = prior_type == "eger" ? EgerPriorCards(player_to, player_from, hint) :
     PriorCards(player_to, player_from, hint);
    let state = sample(prior)

    if(hint.utt == "play" || hint.utt == "discard") {
    }
    else if(hint.pos.includes(state.pos)){
      condition(LiteralMeaning(state.card, hint.utt))
    } else {
      // hint must not be true with respect to any not hinted at card
      // e.g. if card 3 and card 4 are yellow it cannot be the case that
      // card two is also yellow
      condition(!LiteralMeaning(state.card, hint.utt))
    }
    return state
  }})
}

let marginal = function(Distr, var_marginal, player, observer, hint){
  var pos = hint.pos.join(",");
  var disp_hint = (hint.utt == "play" || hint.utt == "discard") ? hint.utt : hint.color;
  display(player+' interprets hint: '+disp_hint+'-'+hint.nb+' at pos'+pos+' from '
          +observer)
  return marginalize(Distr, function(val){
    return var_marginal === "card" ? val.card :
      var_marginal === "intent" ? val.intent :
      var_marginal === "card-intent" ? {card: val.card, intent: val.intent} :
      var_marginal === "card-pos" ? {card: val.card, pos: val.pos} :
      var_marginal === "pos-intent" ? {pos: val.pos, intent: val.intent} : val
  })
}

let marginalPos = function(Distr, indices){
  Infer({model:function(){
    let val = sample(Distr)
    condition(indices.includes(val.pos))
    return val
  }})
}

let actionPrior = cache(function(cards_receiver, cards_giver){
  Infer({model: function(){
    let act = uniformDraw(actions);

    if(act == "play" || act == "discard") {
      let pos = uniformDraw(POSITIONS)
      let card = cards_giver[pos].split("-")
      return {nb: card[1], color: card[0], utt: act, pos: [pos]}
    } else {
      let hint = numbers.includes(act) ? {nb: act, color: "unknown", utt: act} :
      {nb: 'unknown', color: act, utt: act};
      let hints_poss = _.flatten(map(function(card){return card.split("-")},
                                     cards_receiver));
      condition(hints_poss.includes(hint.utt))
      let pos = []
      mapIndexed(function(idx, card){
        if(card.includes(hint.utt)){
          pos.push(idx)
        }
      }, cards_receiver)
      return Object.assign(hint, {pos: pos});
    }
  }})
});

// -------- SPEAKER ------- //
// @arg states: list of states that the speaker wants to convey
let speaker = function(player, addressee, states, prior_type){
  let cards = deck[addressee]
  let PriorHints = actionPrior(cards, deck[player]);
  return(Infer({model:function(){
    let hint = sample(PriorHints);
//     print('hint: ' + hint.utt + ' at ' + hint.pos)
    let ll = LiteralListener(addressee, player, hint, prior_type)
    let scores = [];
    map(function(s){
      let sc = ll.score(s)
      sc !== -Infinity ? scores.push(sc) : null;
//       sc !== -Infinity ? print('pos: ' + s.pos + ' card: ' + s.card +
//                                ' intent: ' + s.intent +
//                                ' score: ' + sc) : null;
    }, states)
    // 1-1 mapping from states to intentions: 1 state maps to exactly 1 intention
    // i.e. there will be a single entry inside scores!
    scores.length !== 0 ? factor(scores[0]) : factor(-Infinity);
    return {utt: hint.utt, pos: hint.pos}
  }}))
}

let receiver = 'player1'
let giver = 'player2'

let actions = actionPrior(deck[giver], deck[receiver])
console.log(sample(actions))


// let hint = {utt: '2', color: 'unknown', nb: "2", pos: [1]}
let hint = {utt: 'red', color: 'red', nb: "unknown", pos: [0, 1]}
// let hint = {utt: 'discard', color: '', nb: "", pos: [0]}

let prior_type = ""
let no_hint = {utt: 'unknown', color: 'unknown', nb: 'unknown', pos:[]}

// -------- PRIOR --------- //

// let prior = prior_type === "eger" ? EgerPriorCards(receiver, receiver, no_hint) :
//  PriorCards(receiver, receiver, no_hint);
// viz(marginal(prior, "card-pos", receiver, receiver, no_hint))
// viz(marginal(prior, "card-intent", receiver, receiver, no_hint))
// viz(marginal(prior, "", receiver, receiver, no_hint))

// let prior_pos = marginalPos(prior, [0])
// viz(marginal(prior_pos, "card-pos", receiver, receiver, no_hint))

// --- Example intents depending on what player knows about particular card --- //
// let context = contextPlayers(['player1'])
// display('player doesnt know anything about her red-2')
// print(sampleIntent({color: 'unknown', nb: 'unknown'}, context['red-2']))

// display('player knows her red-2 is red')
// print(sampleIntent({color: 'red', nb: 'unknown'}, context['red-2']))

// display('player knows her red-2 is a 2')
// print(sampleIntent({color: 'unknown', nb: 2}, context['red-2']))

// display('player knows her red-2 is a red-2 (red-1 is on table)')
// print(sampleIntent({color: 'red', nb: 2}, context['red-2']))

// -------- LITERAL LISTENER --------- //

let LL = LiteralListener(receiver, giver, hint, prior_type)
// // map(print, LL.support())
// viz(marginal(LL, "card-pos", receiver, giver, hint))
// viz(marginal(LL, "card-intent", receiver, giver, hint))
viz(marginal(LL, "pos-intent", receiver, giver, hint))

// ---- SPEAKER --- //
// 1. actionPrior
// let cards = deck[receiver]
// print('cards of ' + receiver)
// print(cards)
// print('hint (utterance) Prior')
// let Prior = actionPrior(cards)
// var _  = map(print, Prior.support())
// viz(marginalize(Prior, function(msg){
//   return {utt: msg.utt, pos: msg.pos}
// }));

// 2. speaker
// todo: add what speaker knows about her cards
// let states =  [{pos: 1, card: "red-2", intent: "relevant"},
//                {pos: 1, card: "red-2", intent: "playable"}];
// let SP = speaker(giver, receiver, states, prior_type)
// console.log(giver + ' hints at ' + receiver)
// viz(SP)


// --- Pragmatic Listener --- //
var pragmatic_listener = function(addressee, player_speaker, hint){
  return Infer({model:function(){
    var state = sample(PriorCards(addressee, player_speaker, hint))
    condition(state.intention !== "irrelevant");
//     print(state)
    observe(speaker(player_speaker, addressee, [state], prior_type),
            {utt: hint.utt, pos: hint.pos})
    return state
  }})
}

let PL = pragmatic_listener(receiver, giver, hint)
// viz(marginal(PL, "card-pos", receiver, giver, hint))
// viz(marginal(PL, "card-intent", receiver, giver, hint))
viz(marginal(PL, "pos-intent", receiver, giver, hint))
